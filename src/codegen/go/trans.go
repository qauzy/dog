package codegen_go

import (
	"bytes"
	"dog/ast"
	log "github.com/corgi-kx/logcustom"
	gast "go/ast"
	"go/format"
	"go/token"
	"io"
	"os"
	"reflect"
	"strconv"
)

func TransGo(p ast.File) (f *gast.File) {

	return transFile(p)
}

func transFile(p ast.File) (f *gast.File) {
	if pp, ok := p.(*ast.FileSingle); ok {
		f = &gast.File{}
		f.Name = gast.NewIdent(pp.Name)
		for _, c := range pp.Classes {
			cl := transClass(c, f)
			f.Decls = append(f.Decls, cl)
		}
		// 输出Go代码
		//header := `// Code generated by log-gen. DO NOT EDIT.`
		header := ""
		buffer := bytes.NewBufferString(header)

		err := astToGo(buffer, f)
		if err != nil {
			return
		}
		//gast.Print(fset, f)
		//gast.Inspect(f, func(n gast.Node) bool {
		//	// Called recursively.
		//	gast.Print(fset, n)
		//	return true
		//})
		WriteFile(buffer.String())
		//fmt.Print(buffer)

	} else {
		panic("bug")
	}
	return
}

//
//
// param: c
// return:
func transClass(c ast.Class, f *gast.File) (cl *gast.GenDecl) {
	if cc, ok := c.(*ast.ClassSingle); ok {
		cl = &gast.GenDecl{
			Doc:    nil,
			TokPos: 0,
			Tok:    token.TYPE,
			Lparen: 0,
			Specs:  nil,
			Rparen: 0,
		}

		sp := &gast.TypeSpec{
			Doc:     nil,
			Name:    gast.NewIdent(cc.Name),
			Assign:  0,
			Type:    nil,
			Comment: nil,
		}
		Type := &gast.StructType{
			Struct: 0,
			Fields: &gast.FieldList{
				Opening: 0,
				List:    nil,
				Closing: 0,
			},
			Incomplete: false,
		}
		sp.Type = Type

		for _, fi := range cc.Fields {
			gfi := transField(fi)
			Type.Fields.List = append(Type.Fields.List, gfi)
		}
		for _, m := range cc.Methods {
			gmeth := transFunc(m)

			//处理类接收
			recv := &gast.FieldList{
				Opening: 0,
				List:    nil,
				Closing: 0,
			}

			gfi := &gast.Field{
				Doc:   nil,
				Names: []*gast.Ident{gast.NewIdent("this")},
				Type: &gast.StarExpr{X: &gast.Ident{
					NamePos: 0,
					Name:    cc.Name,
					Obj:     gast.NewObj(gast.Typ, cc.Name),
				}},
				Tag:     nil,
				Comment: nil,
			}

			recv.List = append(recv.List, gfi)

			gmeth.Recv = recv
			f.Decls = append(f.Decls, gmeth)
		}

		cl.Specs = append(cl.Specs, sp)

	}
	return
}

// 翻译函数抽象语法树
//
// param: fi
// return:
func transFunc(fi ast.Method) (fn *gast.FuncDecl) {
	if method, ok := fi.(*ast.MethodSingle); ok {
		//处理函数参数
		params := &gast.FieldList{
			Opening: 0,
			List:    nil,
			Closing: 0,
		}
		for _, p := range method.Formals {
			params.List = append(params.List, transField(p))
		}
		//处理返回值
		results := &gast.FieldList{
			Opening: 0,
			List:    nil,
			Closing: 0,
		}
		rel := &ast.FieldSingle{
			Access:  0,
			Tp:      method.RetType,
			Name:    "result",
			IsField: false,
			Stms:    nil,
		}
		//如果是void则没有返回值
		ret := transField(rel)
		if ret.Type != nil {
			results.List = append(results.List, ret)
		} else {
			results = nil
		}
		var body = &gast.BlockStmt{
			Lbrace: 0,
			List:   nil,
			Rbrace: 0,
		}
		//处理函数体
		for _, stm := range method.Stms {

			if stm.IsTriple() {
				sss := transTriple(stm)
				if sss != nil && len(sss) > 0 {
					body.List = append(body.List, sss...)
				}
			} else {
				ss := transStm(stm)

				if ss != nil {
					body.List = append(body.List, ss)
				}
			}

		}
		//函数体为空
		if body.List == nil {
			body = nil
		}

		fn = &gast.FuncDecl{
			Doc:  nil,
			Recv: nil,
			Name: gast.NewIdent(Capitalize(method.Name)),
			Type: &gast.FuncType{
				Func:    0,
				Params:  params,
				Results: results,
			},
			Body: body,
		}

	}
	return
}

// 翻译抽象语法树
//
// param: fi
// return:
func transFuncLit(v *ast.Question) (fn *gast.FuncLit) {

	fn = &gast.FuncLit{
		Type: &gast.FuncType{
			Func:    0,
			Params:  nil,
			Results: nil,
		},
		Body: nil,
	}

	one := transExp(v.One)
	two := transExp(v.Two)

	resultOne := &gast.ReturnStmt{
		Return:  0,
		Results: []gast.Expr{one},
	}

	resultTwo := &gast.ReturnStmt{
		Return:  0,
		Results: []gast.Expr{two},
	}

	stmt := &gast.IfStmt{
		If:   0,
		Init: nil,
		Cond: transExp(v.E),
		Body: &gast.BlockStmt{
			Lbrace: 0,
			List:   []gast.Stmt{resultOne},
			Rbrace: 0,
		},
		Else: &gast.BlockStmt{
			Lbrace: 0,
			List:   []gast.Stmt{resultTwo},
			Rbrace: 0,
		},
	}

	fn.Body = &gast.BlockStmt{
		Lbrace: 0,
		List:   []gast.Stmt{stmt},
		Rbrace: 0,
	}
	return
}

func transLambda(fi ast.Exp) (fn *gast.FuncLit) {
	if lam, ok := fi.(*ast.Lambda); ok {
		//处理函数参数
		params := &gast.FieldList{
			Opening: 0,
			List:    nil,
			Closing: 0,
		}
		for _, p := range lam.Formals {
			params.List = append(params.List, transField(p))
		}
		//处理返回值
		results := &gast.FieldList{
			Opening: 0,
			List:    nil,
			Closing: 0,
		}
		//rel := &ast.FieldSingle{
		//	Access:  0,
		//	Tp:      method.RetType,
		//	Name:    "result",
		//	IsField: false,
		//	Stms:    nil,
		//}
		////如果是void则没有返回值
		//ret := transField(rel)
		//if ret.Type != nil {
		//	results.List = append(results.List, ret)
		//} else {
		//	results = nil
		//}
		var body = &gast.BlockStmt{
			Lbrace: 0,
			List:   nil,
			Rbrace: 0,
		}
		//处理函数体
		for _, stm := range lam.Stms {

			if stm.IsTriple() {
				sss := transTriple(stm)
				if sss != nil && len(sss) > 0 {
					body.List = append(body.List, sss...)
				}
			} else {
				ss := transStm(stm)

				if ss != nil {
					body.List = append(body.List, ss)
				}
			}

		}
		//函数体为空
		if body.List == nil {
			body = nil
		}

		fn = &gast.FuncLit{
			Type: &gast.FuncType{
				Func:    0,
				Params:  params,
				Results: results,
			},
			Body: body,
		}

	}
	return
}

// 带类型的变量声明
//
// param: fi
// return:
func transField(fi ast.Field) (gfi *gast.Field) {
	if field, ok := fi.(*ast.FieldSingle); ok {
		//只处理成员变量
		var name = field.Name
		if field.IsField {
			name = Capitalize(field.Name)
		}
		gfi = &gast.Field{
			Doc:     nil,
			Names:   []*gast.Ident{gast.NewIdent(name)},
			Type:    transType(field.Tp),
			Tag:     nil,
			Comment: nil,
		}

	}
	return
}
func transBlock(s ast.Stm) (block *gast.BlockStmt) {
	//log.Infof("解析Block语句")
	block = new(gast.BlockStmt)
	if bl, ok := s.(*ast.Block); ok {
		for _, st := range bl.Stms {
			if st != nil {
				if st.IsTriple() {
					sss := transTriple(st)
					if sss != nil && len(sss) > 0 {
						block.List = append(block.List, sss...)
					}
				} else {
					block.List = append(block.List, transStm(st))
				}

			}

		}

	} else {
		log.Infof("transBlock-->%v--->%v", reflect.TypeOf(s).String(), s)
		panic("bug")
	}

	return
}

// 三元表达式
//
// param: v
// return:
func transTriple(s ast.Stm) (stmts []gast.Stmt) {
	if !s.IsTriple() {
		panic("should triple expr")
	}
	switch v := s.(type) {
	//变量声明
	case *ast.Decl:
		//log.Info("变量声明:", v.Name, "行:", v.LineNum)
		d := &gast.GenDecl{
			Doc:    nil,
			TokPos: 0,
			Tok:    token.VAR,
			Lparen: 0,
			Specs:  nil,
			Rparen: 0,
		}
		sp := &gast.ValueSpec{
			Doc:     nil,
			Names:   []*gast.Ident{gast.NewIdent(v.Name)},
			Type:    transType(v.Tp),
			Values:  nil,
			Comment: nil,
		}
		//临时变量初值
		d.Specs = append(d.Specs, sp)
		stmts = append(stmts, &gast.DeclStmt{Decl: d})

		if vv, ok := v.Value.(*ast.Question); ok {
			q := &gast.IfStmt{
				If:   0,
				Init: nil,
				Cond: transExp(vv.E),
				Body: &gast.BlockStmt{
					Lbrace: 0,
					List: []gast.Stmt{&gast.AssignStmt{
						Lhs:    []gast.Expr{gast.NewIdent(v.Name)},
						TokPos: 0,
						Tok:    token.ASSIGN,
						Rhs:    []gast.Expr{transExp(vv.One)}}},
				},

				Else: &gast.BlockStmt{
					Lbrace: 0,
					List: []gast.Stmt{&gast.AssignStmt{
						Lhs:    []gast.Expr{gast.NewIdent(v.Name)},
						TokPos: 0,
						Tok:    token.ASSIGN,
						Rhs:    []gast.Expr{transExp(vv.Two)}}},
					Rbrace: 0,
				},
			}

			stmts = append(stmts, q)
		} else {
			panic("should triple expr")
		}

		//赋值语句
	case *ast.Assign:
		if vv, ok := v.E.(*ast.Question); ok {
			q := &gast.IfStmt{
				If:   0,
				Init: nil,
				Cond: transExp(vv.E),
				Body: &gast.BlockStmt{
					Lbrace: 0,
					List: []gast.Stmt{&gast.AssignStmt{
						Lhs:    []gast.Expr{gast.NewIdent(v.Name)},
						TokPos: 0,
						Tok:    token.ASSIGN,
						Rhs:    []gast.Expr{transExp(vv.One)}}},
				},

				Else: &gast.BlockStmt{
					Lbrace: 0,
					List: []gast.Stmt{&gast.AssignStmt{
						Lhs:    []gast.Expr{gast.NewIdent(v.Name)},
						TokPos: 0,
						Tok:    token.ASSIGN,
						Rhs:    []gast.Expr{transExp(vv.Two)}}},
					Rbrace: 0,
				},
			}

			stmts = append(stmts, q)
		} else {
			panic("should triple expr")
		}
	//
	case *ast.ExprStm:
		//log.Infof("三元表达式语句:%v", v)
		stmt := &gast.ExprStmt{X: transExp(v.E)}
		stmts = append(stmts, stmt)
	default:
		panic("bug")
		log.Infof("transBlock-->%v -->%v", reflect.TypeOf(s).String(), v)

	}

	return

}

//
//
// param: s
// return:
func transStm(s ast.Stm) (stmt gast.Stmt) {
	switch v := s.(type) {
	//变量声明
	case *ast.Decl:

		//log.Info("变量声明:", v.Name, "行:", v.LineNum)
		d := &gast.GenDecl{
			Doc:    nil,
			TokPos: 0,
			Tok:    token.VAR,
			Lparen: 0,
			Specs:  nil,
			Rparen: 0,
		}
		sp := &gast.ValueSpec{
			Doc:     nil,
			Names:   []*gast.Ident{gast.NewIdent(v.Name)},
			Type:    transType(v.Tp),
			Values:  nil,
			Comment: nil,
		}
		//临时变量初值
		val := transExp(v.Value)
		if val != nil {
			sp.Values = append(sp.Values, val)
		} else {
			log.Infof("初值为空")
		}
		d.Specs = append(d.Specs, sp)
		stmt = &gast.DeclStmt{Decl: d}
		//赋值语句
	case *ast.Assign:
		stmt = &gast.AssignStmt{
			Lhs:    []gast.Expr{transExp(v.Left)},
			TokPos: 0,
			Tok:    token.ASSIGN,
			Rhs:    []gast.Expr{transExp(v.E)},
		}
	case *ast.If:
		var el gast.Stmt
		if v.Elsee != nil {
			el = transBlock(v.Elsee)
		} else {
			el = nil
		}

		stmt = &gast.IfStmt{
			If:   0,
			Init: nil,
			Cond: transExp(v.Condition),
			Body: transBlock(v.Body),
			Else: el,
		}

	//
	case *ast.For:
		//log.Infof("For语句:%v", *v)
		//return  &gast.ExprStmt{X:gast.NewIdent("/**********************/")}
		stmt = &gast.ForStmt{
			For:  0,
			Init: transStm(v.Init),
			Cond: transExp(v.Cond),
			Post: nil,
			Body: transBlock(v.Body),
		}

	case *ast.Range:
		//log.Infof("Range语句:%v", *v)
		stmt = &gast.RangeStmt{
			For:    0,
			Key:    gast.NewIdent("_"),
			Value:  transExp(v.Value),
			TokPos: 0,
			Tok:    token.DEFINE,
			X:      transExp(v.E),
			Body:   transBlock(v.Body),
		}
	case *ast.ExprStm:
		//log.Infof("表达式语句:%v", v)
		stmt = &gast.ExprStmt{X: transExp(v.E)}
	case *ast.Throw:

		log.Infof("Throw语句:%v", v)
		stmt = &gast.ReturnStmt{
			Return:  0,
			Results: nil,
		}
	case *ast.Return:
		//log.Infof("Return语句:%v", v)
		result := &gast.ReturnStmt{
			Return:  0,
			Results: nil,
		}
		if v.E != nil {
			ret := transExp(v.E)
			if ret != nil {
				result.Results = append(result.Results, ret)
			}
		} else {
			log.Infof("空Return语句")
		}
		return result
	default:
		panic("bug")
		log.Infof("transBlock-->%v -->%v", reflect.TypeOf(s).String(), v)

	}

	return
}

func transExp(e ast.Exp) (expr gast.Expr) {
	switch v := e.(type) {
	case *ast.Not:
		expr = &gast.UnaryExpr{
			OpPos: 0,
			Op:    token.NOT,
			X:     transExp(v.E),
		}
	case *ast.Or:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.OR,
			Y:     transExp(v.Right),
		}
	case *ast.And:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.AND,
			Y:     transExp(v.Right),
		}
	case *ast.Lt:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.LSS,
			Y:     transExp(v.Right),
		}
	case *ast.Le:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.LEQ,
			Y:     transExp(v.Right),
		}
	case *ast.Gt:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.GTR,
			Y:     transExp(v.Right),
		}
	case *ast.Ge:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.GEQ,
			Y:     transExp(v.Right),
		}
	case *ast.Eq:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.EQL,
			Y:     transExp(v.Right),
		}
	case *ast.Neq:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.NEQ,
			Y:     transExp(v.Right),
		}
	case *ast.Add:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.ADD,
			Y:     transExp(v.Right),
		}
	case *ast.Sub:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.SUB,
			Y:     transExp(v.Right),
		}
	case *ast.Times:
		expr = &gast.BinaryExpr{
			X:     transExp(v.Left),
			OpPos: 0,
			Op:    token.MUL,
			Y:     transExp(v.Right),
		}

	case *ast.This:
		//log.Infof("This表达式")
		return gast.NewIdent("this")
	case *ast.NewList:
		//log.Infof("初始化List表达式")
		call := &gast.CallExpr{
			Fun:      gast.NewIdent("make"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}

		t := &gast.ArrayType{
			Lbrack: 0,
			Len:    nil,
			Elt:    transType(v.Ele),
		}
		call.Args = append(call.Args, t)

		len := &gast.BasicLit{
			ValuePos: 0,
			Kind:     token.INT,
			Value:    "0",
		}
		call.Args = append(call.Args, len)
		return call
		//TODO 这里需要自己构造一个初始化函数
	case *ast.NewObject:
		call := &gast.CallExpr{
			Fun:      transType(v.T),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}
		for _, a := range v.ArgsList {
			call.Args = append(call.Args, transExp(a))
		}
		return call
	case *ast.NewSet:
		//TODO 实现hashset等数据结构
		expr = &gast.CallExpr{
			Fun:      gast.NewIdent("NewSet"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}
	case *ast.SelectorExpr:
		//	log.Infof("选择表达式,%v, %s", v.X, v.Sel)
		expr = &gast.SelectorExpr{
			X:   transExp(v.X),
			Sel: gast.NewIdent(Capitalize(v.Sel)),
		}
	case *ast.CallExpr:
		fn := transExp(v.Callee)
		call := &gast.CallExpr{
			Fun:      fn,
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}

		for _, a := range v.ArgsList {
			call.Args = append(call.Args, transExp(a))
		}
		return call
	case *ast.Id:
		if _, ok := v.Tp.(*ast.Function); ok {
			v.Name = Capitalize(v.Name)
		}
		return gast.NewIdent(v.Name)
	case *ast.Num:
		return &gast.BasicLit{
			ValuePos: 0,
			Kind:     token.INT,
			Value:    strconv.Itoa(v.Value),
		}
	case *ast.False:
		return gast.NewIdent("false")
	case *ast.True:
		return gast.NewIdent("true")
	case *ast.Null:
		return gast.NewIdent("nil")
	//列表,数组长度表达式
	case *ast.Length:
		call := &gast.CallExpr{
			Fun:      gast.NewIdent("len"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}
		call.Args = append(call.Args, transExp(v.Arrayref))
		return call

	//数组索引表达式
	case *ast.ArraySelect:
		return &gast.IndexExpr{
			X:      transExp(v.Arrayref),
			Lbrack: 0,
			Index:  transExp(v.Index),
			Rbrack: 0,
		}
	case *ast.NewObjectArray:

		if v.Eles == nil {
			call := &gast.CallExpr{
				Fun:      gast.NewIdent("make"),
				Lparen:   0,
				Args:     nil,
				Ellipsis: 0,
				Rparen:   0,
			}

			t := &gast.ArrayType{
				Lbrack: 0,
				Len:    nil,
				Elt:    transType(v.T),
			}
			call.Args = append(call.Args, t)

			len := &gast.BasicLit{
				ValuePos: 0,
				Kind:     token.INT,
				Value:    "0",
			}
			call.Args = append(call.Args, len)
			return call
		} else {
			panic("NewObjectArray bug")
		}
	case *ast.ClassExp:
		return gast.NewIdent("class")
	case *ast.Question:
		return transFuncLit(v)
	case *ast.Lambda:
		return transLambda(v)
	case *ast.NewHash:
		call := &gast.CallExpr{
			Fun:      gast.NewIdent("make"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}

		t := &gast.MapType{
			Map:   0,
			Key:   transType(v.Key),
			Value: transType(v.Ele),
		}
		call.Args = append(call.Args, t)
		return call
	case *ast.NewStringArray:

		call := &gast.CallExpr{
			Fun:      gast.NewIdent("make"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}

		t := &gast.ArrayType{
			Lbrack: 0,
			Len:    nil,
			Elt:    gast.NewIdent("string"),
		}
		call.Args = append(call.Args, t)

		len := &gast.BasicLit{
			ValuePos: 0,
			Kind:     token.INT,
			Value:    "0",
		}
		call.Args = append(call.Args, len)
		return call
	case *ast.NewIntArray:

		call := &gast.CallExpr{
			Fun:      gast.NewIdent("make"),
			Lparen:   0,
			Args:     nil,
			Ellipsis: 0,
			Rparen:   0,
		}

		t := &gast.ArrayType{
			Lbrack: 0,
			Len:    nil,
			Elt:    gast.NewIdent("int"),
		}
		call.Args = append(call.Args, t)

		len := &gast.BasicLit{
			ValuePos: 0,
			Kind:     token.INT,
			Value:    "0",
		}
		call.Args = append(call.Args, len)
		return call
	default:
		log.Infof("%v --> %v", reflect.TypeOf(v).String(), v)
		panic("bug")
	}

	return
}

func transType(t ast.Type) (Type gast.Expr) {
	switch v := t.(type) {
	case *ast.Void:
		return nil
	case *ast.String:
		return gast.NewIdent("string")
	case *ast.StringArray:
		return gast.NewIdent("[]string")
	case *ast.Integer:
		return gast.NewIdent("int64")
	case *ast.Int:
		return gast.NewIdent("int")
	case *ast.IntArray:
		return gast.NewIdent("[]int")
	case *ast.HashType:
		return &gast.MapType{
			Map:   0,
			Key:   transType(v.Key),
			Value: transType(v.Value),
		}
	case *ast.ListType:
		return &gast.ArrayType{
			Lbrack: 0,
			Len:    nil,
			Elt:    transType(v.Ele),
		}
	case *ast.ClassType:
		return &gast.Ident{
			NamePos: 0,
			Name:    v.Name,
			Obj:     gast.NewObj(gast.Typ, v.Name),
		}
	case *ast.ObjectType:
		//return gast.NewIdent("interface{}")
		return &gast.InterfaceType{
			Interface: 0,
			Methods: &gast.FieldList{
				Opening: 0,
				List:    nil,
				Closing: 0,
			},
			Incomplete: false,
		}
	case *ast.Boolean:
		return gast.NewIdent("bool")
		//泛型
		//TODO 先用接口替代
	case *ast.GenericType:
		return &gast.InterfaceType{
			Interface: 0,
			Methods: &gast.FieldList{
				Opening: 0,
				List:    nil,
				Closing: 0,
			},
			Incomplete: false,
		}
	default:

		panic("impossible")
		//log.Info(v.String())
	}
}

func astToGo(dst *bytes.Buffer, node interface{}) error {
	addNewline := func() {
		err := dst.WriteByte('\n') // add newline
		if err != nil {
			log.Info(err)
		}
	}

	addNewline()

	err := format.Node(dst, token.NewFileSet(), node)
	if err != nil {
		return err
	}

	addNewline()

	return nil
}
func Capitalize(str string) string {
	var upperStr string
	vv := []rune(str) // 后文有介绍
	for i := 0; i < len(vv); i++ {
		if i == 0 {
			if vv[i] >= 97 && vv[i] <= 122 { // 后文有介绍
				vv[i] -= 32 // string的码表相差32位
				upperStr += string(vv[i])
			} else {
				//log.Info("Not begins with lowercase letter,")
				return str
			}
		} else {
			upperStr += string(vv[i])
		}
	}
	return upperStr
}

func checkFileIsExist(filename string) bool {
	var exist = true
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		exist = false
	}
	return exist
}

func WriteFile(s string) (err error) {
	//var filename = "D:\\code\\dog\\src\\codegen\\go\\example\\test.go"
	var filename = "/opt/google/code/dog-comp/src/codegen/go/example/test.go"
	var f *os.File
	/***************************** 第一种方式: 使用 io.WriteString 写入文件 ***********************************************/
	if checkFileIsExist(filename) { //如果文件存在
		f, err = os.OpenFile(filename, os.O_TRUNC|os.O_WRONLY, 0666) //打开文件
	} else {
		f, err = os.Create(filename) //创建文件
	}
	if err != nil {
		return
	}
	_, err = io.WriteString(f, s) //写入文件(字符串)
	return
}

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
)

var srcCode = `
package hello

import "fmt"

func greet() {
	//这里是注释
    var msg = "Hello World!"
    fmt.Println(msg)
}
`

func main() {
	fset := token.NewFileSet()

	f, err := parser.ParseFile(fset, "", srcCode, parser.ParseComments)
	if err != nil {
		fmt.Printf("err = %s", err)
	}

	f = &ast.File{}
	f.Name = ast.NewIdent("hello")

	im := &ast.GenDecl{
		Doc:    nil,
		TokPos: 0,
		Tok:    token.IMPORT,
		Lparen: 0,
		Specs:  nil,
		Rparen: 0,
	}

	sp := &ast.ImportSpec{
		Doc:  nil,
		Name: nil,
		Path: &ast.BasicLit{
			ValuePos: 8,
			Kind:     token.STRING,
			Value:    "\"fmt\"",
		},
		Comment: nil,
		EndPos:  0,
	}
	im.Specs = append(im.Specs, sp)

	f.Decls = append(f.Decls, im)

	fn := &ast.FuncDecl{
		Doc:  nil,
		Recv: nil,
		Name: ast.NewIdent("main"),
		Type: &ast.FuncType{
			Func:    0,
			Params:  nil,
			Results: nil,
		},
		Body: nil,
	}
	f.Decls = append(f.Decls, fn)

	//ast.Print(fset, f)
	// 输出Go代码
	header := `// Code generated by log-gen. DO NOT EDIT.`
	buffer := bytes.NewBufferString(header)

	err = astToGo(buffer, f)
	if err != nil {
		return
	}
	ast.Print(fset, f)
	ast.Inspect(f, func(n ast.Node) bool {
		// Called recursively.
		ast.Print(fset, n)
		return true
	})

	fmt.Print(buffer)
}

func astToGo(dst *bytes.Buffer, node interface{}) error {
	addNewline := func() {
		err := dst.WriteByte('\n') // add newline
		if err != nil {
			log.Panicln(err)
		}
	}

	addNewline()

	err := format.Node(dst, token.NewFileSet(), node)
	if err != nil {
		return err
	}

	addNewline()

	return nil
}

func writeGoFile(wr io.Writer, funcs []ast.Decl) (err error) {
	// 输出Go代码
	header := `// Code generated by log-gen. DO NOT EDIT.
package log
`
	buffer := bytes.NewBufferString(header)

	for _, fn := range funcs {
		err = astToGo(buffer, fn)
		if err != nil {
			return
		}
	}

	_, err = wr.Write(buffer.Bytes())
	return err
}
